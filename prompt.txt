export type Direction = "UP" | "RIGHT" | "DOWN" | "LEFT";

export type Coordinates = {
	x: number;
	y: number;
};

export type Merger = {
    toId: number;
    fromId: number;
};

type TileState = {
	id: number;
	coordinates: Coordinates;
	power: number;
};

export type FieldState = {
	tiles: TileState[];
};


export function calculateTurn(
	gameSize: number,
	fieldState: FieldState,
	direction: Direction
): { newFieldState: FieldState; newMergers: Merger[] } {
	const newFieldState: FieldState = {
		tiles: fieldState.tiles.map((tile) => ({ ...tile })), // Deep clone
	};

	const newMergers: Merger[] = [];

	if (direction === "LEFT") {
		// iterating over the rows
		for (let y = 0; y < gameSize; y++) {
			const tileRow = newFieldState.tiles.filter((tile) => tile.coordinates.y === y);
			if (tileRow.length === 0) continue;
			// iterate from left to right
			for (let x = 1; x < gameSize; x++) {
				const tile = tileRow.find((tile) => tile.coordinates.x === x);
				if (!tile) continue;
				let nearestLeftTile;
				for (let i = x - 1; i >= 0; i--) {
					nearestLeftTile = tileRow.find((tile) => tile.coordinates.x === i);
					if (nearestLeftTile) break;
				}
				if (!nearestLeftTile) {
					// move tile to the left
					tile.coordinates.x = 0;
				} else if (
					// the power of the nearest left tile is equal to the power of the current tile
					nearestLeftTile.power === tile.power &&
					// nearest left tile is not already merged
					!newMergers.flatMap((merger) => [merger.toId, merger.fromId]).includes(nearestLeftTile.id)
				) {
					// merge tiles
					tile.coordinates = nearestLeftTile.coordinates;
					newMergers.push({ toId: nearestLeftTile.id, fromId: tile.id });
				} else {
					// move tile right to the nearest left tile
					tile.coordinates.x = nearestLeftTile.coordinates.x + 1;
				}
			}
		}
	} else if (direction === "RIGHT") {
		// iterating over the rows
		for (let y = 0; y < gameSize; y++) {
			const tileRow = newFieldState.tiles.filter((tile) => tile.coordinates.y === y);
			if (tileRow.length === 0) continue;
			// iterate from right to left
			for (let x = gameSize - 2; x >= 0; x--) {
				const tile = tileRow.find((tile) => tile.coordinates.x === x);
				if (!tile) continue;

				let nearestRightTile;
				for (let i = x + 1; i < gameSize; i++) {
					nearestRightTile = tileRow.find((tile) => tile.coordinates.x === i);
					if (nearestRightTile) break;
				}

				if (!nearestRightTile) {
					// move tile to the right
					tile.coordinates.x = gameSize - 1;
				} else if (
					// the power of the nearest right tile is equal to the power of the current tile
					nearestRightTile.power === tile.power &&
					// nearest right tile is not already merged
					!newMergers.flatMap((merger) => [merger.toId, merger.fromId]).includes(nearestRightTile.id)
				) {
					// merge tiles
					tile.coordinates = nearestRightTile.coordinates;
					newMergers.push({ toId: nearestRightTile.id, fromId: tile.id });
				} else {
					// move tile left to the nearest right tile
					tile.coordinates.x = nearestRightTile.coordinates.x - 1;
				}
				console.groupEnd();
			}
		}
	} else if (direction === "UP") {
		// iterating over the columns
		for (let x = 0; x < gameSize; x++) {
			const tileColumn = newFieldState.tiles.filter((tile) => tile.coordinates.x === x);
			if (tileColumn.length === 0) continue;
			// iterate from top to bottom
			for (let y = 1; y < gameSize; y++) {
				const tile = tileColumn.find((tile) => tile.coordinates.y === y);
				if (!tile) continue;
				let nearestTopTile;
				for (let i = y - 1; i >= 0; i--) {
					nearestTopTile = tileColumn.find((tile) => tile.coordinates.y === i);
					if (nearestTopTile) break;
				}
				if (!nearestTopTile) {
					// move tile to the top
					tile.coordinates.y = 0;
				} else if (
					// the power of the nearest top tile is equal to the power of the current tile
					nearestTopTile.power === tile.power &&
					// nearest top tile is not already merged
					!newMergers.flatMap((merger) => [merger.toId, merger.fromId]).includes(nearestTopTile.id)
				) {
					// merge tiles
					tile.coordinates = nearestTopTile.coordinates;
					newMergers.push({ toId: nearestTopTile.id, fromId: tile.id });
				} else {
					// move tile down to the nearest top tile
					tile.coordinates.y = nearestTopTile.coordinates.y + 1;
				}
			}
		}
	} else if (direction === "DOWN") {
		// iterating over the columns
		for (let x = 0; x < gameSize; x++) {
			const tileColumn = newFieldState.tiles.filter((tile) => tile.coordinates.x === x);
			if (tileColumn.length === 0) continue;
			// iterate from bottom to top
			for (let y = gameSize - 2; y >= 0; y--) {
				const tile = tileColumn.find((tile) => tile.coordinates.y === y);
				if (!tile) continue;
				let nearestBottomTile;
				for (let i = y + 1; i < gameSize; i++) {
					nearestBottomTile = tileColumn.find((tile) => tile.coordinates.y === i);
					if (nearestBottomTile) break;
				}
				if (!nearestBottomTile) {
					// move tile to the bottom
					tile.coordinates.y = gameSize - 1;
				} else if (
					// the power of the nearest bottom tile is equal to the power of the current tile
					nearestBottomTile.power === tile.power &&
					// nearest bottom tile is not already merged
					!newMergers.flatMap((merger) => [merger.toId, merger.fromId]).includes(nearestBottomTile.id)
				) {
					// merge tiles
					tile.coordinates = nearestBottomTile.coordinates;
					newMergers.push({ toId: nearestBottomTile.id, fromId: tile.id });
				} else {
					// move tile up to the nearest bottom tile
					tile.coordinates.y = nearestBottomTile.coordinates.y - 1;
				}
			}
		}
	}
	return {
		newFieldState,
		newMergers,
	};
}


Optimize this function.

